---
layout: post
title: 杂记
date: 2019-03-07
categories: blog
tags:
  - other
  - 前端
---

平时记录的小知识点

最后更新时间 2019-04-23

<!-- more -->

争取在一个月一清

# 杂记

## event bus

不用单独在 `utils` 文件夹下建立一个 `bus.js` 文件来只挂载 `vue`，可以在 `main.js` 中全局注入 `Vue.prototype.$bus = new Vue()`

## @input 和 :value

`v-module` 的语法糖

> 默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。

```html
<my-checkbox :checked="foo" @change="val => { foo = val }" value="some value">
</my-checkbox>
```

```js
 model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    value: String,
    checked: {
      type: Number,
      default: 0
    }
  }
```

## 为什么不用 `map` 来遍历循环验证图片 `size`，而是使用 `for-in` 来循环

获得图片 size 的方法是异步的，会跑出来一个 Promise

## 两个 `image` 元素之间有间隙

根本原因在于 `img` 标签为 `inline` 元素，该元素默认垂直对齐方式为以父元素的 `baseline`，但是展示时又是以 `bottomline` 为对齐方式，因此造成了上下两个 `img` 标签之间的间隙。

- `img` 本来是行内元素，却可以用 `width` 和 `height`,当父元素没有设置高度的时候，用子元素们的高度计算出的高度给父元素的时候就会出现 `3px` 空隙这类的问题。

- `img` 图片默认排版为 `inline-block`;而所有的 `inline-block` 元素之间都会有空白。

解决方法：

- 给图片增加样式 `display：block`
- `img{vertical-align:top;}` 改变其垂直对齐方式
- `div{font-size:0}` 把父元素的文字大小设置为 0
- `div{ margin-bottom:-3px }`

## 前端安全需要注意哪几方面问题

xss、csrf、arp、xff、中间人攻击、运营商劫持、防暴刷

## `token` 加密和登陆验证

JWT（JSON Web Tokens）用户发送登陆信息至服务器，服务器认证后，生成一个 `JSON` 对象，返回给用户，服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。
缺点：由于服务器不保存 `session` 状态，因此无法在使用过程中废止某个 `token`，或者更改 `token` 的权限。也就是说，一旦 `JWT` 签发了，在到期之前就会始终有效。（设置较短的有效期）

- 可以保存在 `localStorage` 或`sessionStorage` 中， 用户再次与服务端通信的时候，都要在`HTTP header`中 `Authorization` 字段里，携带服务器返回的 `JSON`。

```js
Authorization: Bearer <token>
```

- 也可以储存在 `Cookie` 里面，在请求的时候自动发送，但是不能跨域

** 数据格式 **

`Header.Payload.Signature`
需要使用 `Base64` 转为 字符串

- Header (头部)
- Payload (负载)
- Signature (签名)

### Header

JSON 对象

```js
{
 "alg": "HS256", // 签名所用的算法，默认 `HMAC SHA256（HS256)`
 "typ": "JWT" //token 类型
}
```

### Payload

JSON 对象

```js
  {
    "iss": "签发人",
    "exp": "过期时间",
    "nbf": "生效时间",
    "iat": "签发时间",
    "jti": "编号"
  }
```

### Signature

对 `Header` 和 `Payload` 的签名，防止被篡改

简单的使用方法：

- 需要一个 `secret`（随机数）
- 后端利用 `secret` 和加密算法(如：HMAC-SHA256)对 `payload`(如账号密码)生成一个字符串(`token`)，返回给前端
- 前端每次 `request` 在 `header` 中带上登陆返回的 `token`
- 后端用同样的算法解密

### 0.1 + 0.2 ！= 0.3

浮点数比较方法：使用最小精度值
`Math.abs(0.1+0.2-0.3) <= Number.EPSILON`
