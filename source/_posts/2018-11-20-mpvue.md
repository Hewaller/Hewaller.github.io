---
layout: post
title: mpvue--微信小程序
date: 2018-11-20
categories: blog
tags: [JavaScript, vue, 小程序]
description: mpvue框架的使用
---

# 主要特点

&nbsp; &nbsp; &nbsp;小程序版本的`Vue.js`

- 彻底的组件化开发能力：提高代码复用性
- 完整的 `Vue.js` 开发体验
- 方便的 `Vuex` 数据管理方案：方便构建复杂应用
- 快捷的 `webpack` 构建机制：自定义构建策略、开发阶段 hotReload
- 支持使用 npm 外部依赖
- H5 代码转换编译成小程序目标代码的能力

## 生命周期

有趣的是 [mpvue](http://mpvue.com/mpvue/#_5) 框架的生命周期是融合了`vue`和`小程序`的生命周期，重新组合的一套兼容 [mini-app](https://developers.weixin.qq.com/miniprogram/dev/api/)的一套完整生命周期

> 特点：

    1. 在小程序的onReady后，才会去出发 mounted的生命周期
    2. 如果每次进入页面都要重新请求数据，建议使用onShow来请求数据，但是用户体验不太好, 如果只需要在第一次进入页面时请求数据，随后的数据都不改变，应该使用mounted，不必要频繁的去请求接口、刷新页面。
    3.官方文档上建议使用Vue的生命周期函数
    4. 小程序的 `onPullDownRefresh` 能够检测到页面下拉动作，可以用来实现上拉刷新的操作， 需要搭配 `stopPullDownRefresh` 来使用
    5. `onReachBottom` 页面上拉触底事件的处理函数，

### 小程序实现下拉刷新的操作

```js
async onPullDownRefresh() {
    wx.showLoading();
    ....
    // 相应的上拉事件处理函数　
    setTimeout(() => {
      wx.hideLoading();
      wx.stopPullDownRefresh();
    }, 1000);
  },
```

#### 页面触底之后的上拉操作

```js
async onReachBottom() {
    // 首屏时只展示部分数据，未展示所有的数据
    // 判断当前的数据量是不是后台接口返回的总数据量
    if (this.List.length < this.total) {
    // 数据没有完全被加载，上拉一次再次加载一次数据
      this.pageData.page = this.pageData.page + 1;
      const List = this.List;
      const data = await fetchExpertsDetail(this.pageData);
      this.List = [...answerList, ...data.answer]; // 合并新请求的数据和老的数据
    } else {
    // 如果全加载了，给个提示
      console.log('到底啦');
    }
  },
```

#### 小程序的路由跳转

> 要注意跳转到非 tabBar 页和 跳转到 tabBar 导航页

1. 跳转到到导航页： wx.switchTab(Object object) 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
2. 跳转到非导航页： wx.navigateTo(Object object) 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原跳转的页面，原页面没有被销毁。
3. wx.redirectTo(Object object) 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。

> 跳转的 query 参数  
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信小程序的页面的 `query` 参数是通过 `onLoad` 获取的，`mpvue` 进行了优化，直接通过 `this.$root.$mp.query` 获取相应的参数数据，其调用需要在 `onLoad` 生命周期触发之后使用

#### mpvue 暂时不能使用的语法

1. 不支持 `纯-HTML` ，小程序不支持所有的 DOM 和/BOM 操作，`v-html` 的语法是不能用的
2. 尽量不要在代码的双花括号中处理数据，例如：三元判断，字符处理等等的，`compouted` 是更好的选择
3. 在列表循环渲染时： 一定要牢记，千万不要在嵌套的 for 循环中使用相同的 index

```js
<ul v-for="(card, index) in list">
        <li v-for="(item, itemIndex) in card">
            {{item.value}}
        </li>
    </ul>
```

4. 事件修饰符： `.stop` 能处理一些预料之外的情况
5. 不支持在组件引用时，在组件上定义原生的事件（click），并且 class 和 style 等样式属性也不会生效，解决样式的问题： 写在内部顶级元素上，不要使用 scoped 来限制，可以加一个顶级 class 来防止 class 样式外泄

#### 小程序表单和 video

> 小程序的坑： textarea 和 video 当被激活时他们的层级永远是最高的，无法去处理
> textarea 的处理方法： 当需要在 `textarea` 的上方加上一个弹窗活着页面时，需要手动的把 `textarea` 隐藏，换一种方法来实现  
> video 暂时还不知道怎么处理，同时还要注意视频的播放问题，在离开页面的时候要强制的关闭视频

### 小程序的登陆逻辑

> 现如今的小程序已经不在支持强制登陆，而是需要用户点击登陆按钮之后才能获取登陆权限，为了防止每次登陆的时候都会弹出一个默认的弹出框，仅仅是在首次登陆的时候弹出授权框，提升用户体验。

实现的逻辑：
首次登陆： 去拿用户的 `code` 之后，发送 code 给后台换取 session_key、unionid, openid， 这个请求的过程一般是在打开登陆界面的时候已经调用了（此时已经取得了 session_key），当用户点击登陆的时候才会去调取登陆接口，拿获得 session 去换取用户信息。  
 此时还拿到了 token，用于用户以后的登陆，作为登陆的另外一个依据
二次登陆： 静默登陆，拿到第一次返回的数据进行登陆，不再使微信打开获取登陆权限的弹窗

```js
// HTML
 <button class="center-flex btn wx-btn" hover-class="opacity" type="primary" open-type="getPhoneNumber" @getphonenumber="getphonenumber">
      <img src="/static/images/wechat.png" class="wx-icon">
      <div class="wx-text">微信手机号登陆</div>  为了获取权限
    </button>
  <button @click="toBind" hover-class="opacity" class="center-flex btn phone-btn">手机验证码登陆</button>

  // js
  import { login, phoneLogin } from '@/utils/login'
  import { redirectBack, getCurrentOptions } from '@/utils'
  import authority from '@/utils/authority'

  export default {
    methods: {
      login() {
        authority.clear() //登陆前清除用户信息
        login()
      },
      toBind() {
        const { back } = getCurrentOptions()  // 手动输入手机号 跳转到另一个登陆页面
        wx.navigateTo({
          url: `/pages/bind/main?back=${back}`
        })
      },
      getphonenumber(e) {
        const { encryptedData, iv } = e.target  // 判断是否包含特殊的数据，通俗来说用户是否同意了登陆权限
        if (!encryptedData) {
          return this.toBind()
        } else {
          phoneLogin({
            encrypted_data: encryptedData,
            iv
          }).then(() => {
            wx.showToast({
              title: '登陆成功'
            })
            redirectBack()  // 返回前一个需要登陆的页面
          }).catch((e) => {
            console.error(e)
            this.toBind()
          })
        }
      }
    },
    onShow() {
      this.login()
    }

```

2018 年 11 月 20 日
