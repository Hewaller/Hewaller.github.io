---
layout: post
title: ES6、ES7、ES8、ES9踩坑总结
date: 2018-12-18
categories: blog
tags: [JavaScript, 前端]
description: ES6、ES7、ES8、ES9踩坑总结
---

# ES6、ES7、ES8、ES9

## 解构赋值

具体使用： 数组和对象的解构

> 注意点： 对象结构不需要严格按照索引的顺序排列，只要按照变量名去取对应属性名的值，若取不到对应属性名的值，则为 undefined 。但是由于数组的索引是默认数字，解构必须严格按照顺序取值，取不到也为 undefined

```js
let [a, b, ..c.] = [1];
console.log(a, b, c); // 1, undefined, []

let {a} = {a:3, b:2, c:1};// a => 3
// 如果变量名和属性名不一致，其实实际要读取的是属性名

let {a:b} = {a:1, c:2}
console.log(a)// error: a is not defined
console.log(b)// b => 1

//实际运用中一般需要给一个默认值，防止为undefined导致报错
 function test({a = 123} = {}) {
  //  防止传入的对象中没有a属性，导致函数报错
   console.log(a)
 }
const obj = {b: 456}
test(obj)

function fun ({a, b} = {a:0, b:0}){
    return [a, b];
}
fun ({a:1, b:2}); // [1, 2]
fun ({a:1});      // [1, undefined]
fun ({});         // [undefined, undefined]
fun ();           // [0, 0]

// 交换变量
let a = 1,b = 2;
[a, b] = [b, a]; // a =>2 , b => 1
```

## 拓展赋值

拓展运算符使用(...)，类似 rest 参数的逆运算，将所需要的数据转为用(,)分隔的参数序列。
也是实现深拷贝的一种实现方式

```js
console.log(1, ...[2, 3], 4) // 1 2 3 4
// 实际运用，后台实现路由query的实时更新，覆盖默认值和添加没有的key
saveParams(payload) {
  this.payload = {...this.payload, ...payload}
  this.$router.replace({query: {...this.$route.query, ...this.payload}})
}

// 实现简单的数组的深拷贝
const a1 = [1, 2];
const a2 = [...a1];
a2[0] = 3; //指针未指向a1，只改变了a2，没有改变a1,实现了简单的深拷贝
console.log(a1,a2); // [1,2] [3,2]

// 分离数组， 可以用开判断数组是不是为空
let [a, ...b] = [1, 2, 3, 4]
// a => 1  b => [2,3,4]
let [a, ...b] = [];
// a => undefined b => []
```

## 数组的处理方式

参考上一篇的数组处理方式
