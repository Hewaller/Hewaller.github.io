---
layout: post
title: 登陆流程
date: 2018-11-25
categories: weChat
tags: [weChat, 前端, 小程序]
description: 小程序登陆
---

###改变

> 原来我们在首次进入小程序时，会通过 getUserInfo 调起用户授权的弹窗，但是根据微信小程序，最新更新解释，开发工具，体验版本将不再支持这个授权方式而是通过 button 组件让用户自主去点击已完成授权目的（这个对开发者来说真的是很蛋疼）,

> 解决方案： 设置一个用户登陆的过渡页面

```js
  <button wx:if="{{canIUse}}" open-type="getUserInfo" bindgetuserinfo="bindGetUserInfo">授权登录</button>
  <view wx:else>请升级微信版本</view>  //让用户自己去点击这个授权登录的按钮，然后再去进行后续的业务逻辑
```

### 小程序登陆逻辑

```js
import request from '@/utils/request/baseRequest'
import authority from '@/utils/authority' // 将数据存取Storage里
import { getCurrentOptions, getCurrentUrl } from '@/utils'
// 小程序当前页面url和路径参数 和 获取小程序当前路由参数 方法

// code 换取 session_key

async function fetchSessionKey(code) {
  const { session_key, unionid, token, openid = '', user = {} } = await request(
    {
      url: '/api/app/v1/miniapp/session',
      method: 'post',
      data: { code }
    }
  )
  user.session_key = session_key
  user.unionid = unionid
  user.openid = openid
  authority.set(user)
  if (token) {
    user.token = token
    authority.set(user)
    const { back } = getCurrentOptions()
    if (!back) return
    wx.reLaunch({
      url: decodeURIComponent(back)
    })
  } else {
    const back = getCurrentUrl()
    // 重定向对路页面
    if (!back.startsWith('/pages/login/main')) {
      wx.redirectTo({
        url: `/pages/login/main?back=${encodeURIComponent(back)}`
      })
    }
    authority.set({ session_key, unionid })
  }
  return true
}

export default () => {
  return new Promise((resolve, reject) => {
    const user = authority.get() || {}
    if (user.token) return resolve(user) // todo

    const errorHandle = e => {
      console.error(e)
      wx.showToast({
        title: '获取code失败',
        icon: 'none'
      })
      reject(e)
    }

    wx.login({
      success({ code }) {
        fetchSessionKey(code)
          .then(resolve)
          .catch(errorHandle)
      },
      fail(e) {
        console.log(11)
        errorHandle(e)
      }
    })
  })
}
```

## wx.getStorageSync And wx.setStorageSync

1. 读取信息的时候要使用 try/catch 捕捉错误
2. key 要唯一
3. 清除数据之前要保存重要的信息： 用于登陆所需的信息

```javascript
const key = 'user_info' // 定义储存的key，一定要确保是单一的
const maxAge = 1000 * 60 * 60 * 24 * 60 // 设置过期时间，60天过期

export default {
  get() {
    // 获取存储到localStorage中的数据，一般是用户信息，使用try/catch捕捉错误
    try {
      const user = wx.getStorageSync(key)
      if (!user || user.time + maxAge < Date.now()) return null
      // 如果储存的时间过期了，直接返回null，重新发送登陆接口获取
      return user || {}
    } catch (e) {
      return {}
    }
  },
  set(user) {
    if (!user) return null
    // 存储数据，没有数据直接返回null，外部捕捉这个null来判定是否成功
    user.time = Date.now()
    // 设置储存时间，用来判断是否过期
    const oldUser = this.get() || {}
    const newUser = { ...oldUser, ...user } //将以前的数据和新的数据一起整合在一起
    console.log(newUser, 'newuser')
    wx.setStorageSync(key, newUser) //微信存储数据的静态方法
    return newUser
  },
  clear() {
    const user = this.get() || {}
    const { regionCode = '', currentCity = '', shop_id = '' } = user
    // 即使是清除数据，也保存重要的登陆信息
    wx.clearStorageSync()
    this.set({ regionCode, currentCity, shop_id })
    // 清空完之后再次储存
    return user
  }
}
```

> 2018 年 11 月 25 日
