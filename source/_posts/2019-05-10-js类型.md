---
title: 'JS类型判断和类型转换'
date: 2019-05-11
categories: JavaScript# 分类只能有1个
tags:
  - JavaScript
  - 前端
---

JS 中其中类型判断和类型转换

参考文章： 你不知道的 JavaScript、冴羽的 JavaScript 专题系列

<!-- more -->

## 7 种类型

- String
- Number
- Boolean
- Null
- undefined
- Symbol
- Object

## 类型判断

### 使用 `typeof` 类型判断

```js
typeof undefined // "undefined"
typeof true // "boolean"
typeof 1 // "number"
typeof 's' // "string"
typeof {} // "object"
typeof Symbol() // "symbol"
// 特殊类型
typeof null // "object"

// 检测 null 值的类型
const a = null
!a && typeof a === 'object' // true
```

> `object` 类型中还包含很多的'子类型'， Array、Function、Date、RegExp、Error， 但是函数例外

`typeof function a(){ /* .. */ } === "function"; // true`

> function(函数)也是 JavaScript 的一个内置类型。实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性 `[[Call]]`，该属性使其可以被调用

```js
//typeof 只有 function 的情况下返回 'function',其他类型都返回 `object`
typeof new Date() // object
typeof new Error() // object
```

### `Object.prototype.toString` 更详细的检测类型

- 如果 `this` 值是 `undefined` ，就返回 `[object Undefined]`
- 如果 `this` 的值是 `null` ，就返回 `[object Null]`
- 返回由 `"[object ", class and "]"`三个部分组成的字符串
  > 至少 17 种类型：Number, String, Boolean, Undefined, Null, Object, Function, Array, Date, Error, RegExp, Math, JSON, Arguments Symbol Set Map

```js
//  demo 返回的 `class` 就是我们期望的类型， 与 `typeof` 不同的是，这里返回的类型，首字母都是大写的
Object.prototype.toString.call(undefined) // [object Object]
Object.prototype.toString.call(null) // [object Object]

Object.prototype.toString.call(Symbol()) //[object Symbol]
Object.prototype.toString.call(new Set()) //[object Set]
Object.prototype.toString.call(new Map()) //[object Map]
Object.prototype.toString.call(new Date()) // [object Date]
Object.prototype.toString.call(Math) // [object Math]

a = () => {
  console.log(Object.prototype.toString.call(arguments)) // [object Arguments]
}
a()
```

```js
var classType = {}
// 来自 `冴羽的 JavaScript 专题系列`
// 生成classType映射
'Boolean Number String Function Array Date RegExp Object Error Symbol Set Map'
  .split(' ')
  .map((item, index) => {
    classType['[object ' + item + ']'] = item.toLowerCase()
  })

type = obj => {
  // 一箭双雕
  if (obj == null) {
    return obj + ''
  }
  return typeof obj === 'object' || typeof obj === 'function'
    ? classType[Object.prototype.toString.call(obj)] || 'object'
    : typeof obj
}
```

## 类型值简介

### `Undefined` 和 `null`

`undefined` 类型只有一个值，即 `undefined`。`null` 类型也只有一个值，即 `null`。它们的名称既是类型也是值。

- `undefined` 指从未赋值， `undefined` 却是一个标识符，在非严格条件下可以被当作变量来使用和赋值， 在严格模式下可以声明一个名为 `undefined` 的局部变量
- `null` 指曾赋过值，但是目前没有值， `null` 是一个 `JavaScript` 关键字，不是标识符，我们不能将其当作变量来使用和赋值

> `void` 运算符: 表达式`void ___`没有返回值，因此返回结果是`undefined`。
> 为了避免无意中被篡改，使用`void 0` 来获取 `undefined` 值

### String

`String` 有最大长度是 `2^53 - 1`，`String` 的意义并非“字符串”，而是字符串的 `UTF16` 编码，我们字符串的操作 `charAt`、`charCodeAt`、`length` 等方法针对的都是 `UTF16` 编码， `JavaScript` 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串的内容，所以字符串具有值类型的特征

> 区别于数组：

```js
let a = 'foo'
let b = ['f', 'o', 'o']

a[1] = 'O' // "foo" 字符串是不可变的
// a.charAt(1) 取值是不是更优雅一些
b[1] = 'O' // ["f","O","o"]

// 字符串不能直接反转，数组可以
a.reverse() //undefined
b.reverse() //["o","o","f"]

// 实现字符串反转
a.split('')
  .reverse()
  .join('') // ["o","o","f"]
```

### Number

> `JavaScript` 中的 `Number` 类型有 `18437736874454810627`(即 `2^64-2^53+3`) 个值

`JavaScript` 为了表达几个额外的语言场景(比如不让除以 `0` 出错，而引入了无穷大的概念)，规定了几个例外情况:

- NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字;
- Infinity，无穷大;
- -Infinity，负无穷大

> `JavaScript` 中有 `+0` 和 `-0`，在加法类运算中它们没有区别，但是除 法的场合则需要特别留意区分，“忘记检测除以 `-0`，而得到负无穷大”的情况经常会导致 错误，而区分 `+0` 和 `-0` 的方式，正是检测 `1/x` 是 `Infinity` 还是 `-Infinity`

#### 较小的数值

`JavaScript` 中的 `Number` 类型基本符合 `IEEE 754-2008` 规定的双精度浮点数规则，二进制浮点数最大的问题是
`0.1 + 0.2 === 0.3; // false`

> 二进制浮点数中的 `0.1 和 0.2` 并不是十分精确，它们相加的结果并非刚好等于 `0.3`，而是一个比较接近的数字 `0.30000000000000004`，所以条件判断结果为 `false`

正确的比较方法是使用 `JavaScript` 提供的最小精度值:
`console.log( Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);`

#### 整数的检测

要检测一个值是否是整数，可以使用 ES6 中的 Number.isInteger(..) 方法:

```js
Number.isInteger(42) // true
Number.isInteger(42.0) // true
Number.isInteger(42.3) // false
```
