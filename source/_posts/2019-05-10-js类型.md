---
title: 'JS类型判断和类型转换'
date: 2019-04-11
categories: JavaScript# 分类只能有1个
tags:
  - JavaScript
  - 前端
---

JS 中其中类型判断和类型转换

参考文章： 你不知道的 JavaScript、冴羽的 JavaScript 专题系列

<!-- more -->

## 7 种类型

- String
- Number
- Boolean
- Null
- undefined
- Symbol
- Object

## 类型判断

### 使用 `typeof` 类型判断

```js
typeof undefined // "undefined"
typeof true // "boolean"
typeof 1 // "number"
typeof 's' // "string"
typeof {} // "object"
typeof Symbol() // "symbol"
// 特殊类型
typeof null // "object"

// 检测 null 值的类型
const a = null
!a && typeof a === 'object' // true
```

> `object` 类型中还包含很多的'子类型'， Array、Function、Date、RegExp、Error， 但是函数例外

`typeof function a(){ /* .. */ } === "function"; // true`

> function(函数)也是 JavaScript 的一个内置类型。实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属性 `[[Call]]`，该属性使其可以被调用

```js
//typeof 只有 function 的情况下返回 'function',其他类型都返回 `object`
typeof new Date() // object
typeof new Error() // object
```

### `Object.prototype.toString` 更详细的检测类型

- 如果 `this` 值是 `undefined` ，就返回 `[object Undefined]`
- 如果 `this` 的值是 `null` ，就返回 `[object Null]`
- 返回由 `"[object ", class and "]"`三个部分组成的字符串
  > 至少 17 种类型：Number, String, Boolean, Undefined, Null, Object, Function, Array, Date, Error, RegExp, Math, JSON, Arguments Symbol Set Map

```js
//  demo 返回的 `class` 就是我们期望的类型， 与 `typeof` 不同的是，这里返回的类型，首字母都是大写的
Object.prototype.toString.call(undefined) // [object Object]
Object.prototype.toString.call(null) // [object Object]

Object.prototype.toString.call(Symbol()) //[object Symbol]
Object.prototype.toString.call(new Set()) //[object Set]
Object.prototype.toString.call(new Map()) //[object Map]
Object.prototype.toString.call(new Date()) // [object Date]
Object.prototype.toString.call(Math) // [object Math]

a = () => {
  console.log(Object.prototype.toString.call(arguments)) // [object Arguments]
}
a()
```

```js
var classType = {}
// 来自 `冴羽的 JavaScript 专题系列`
// 生成classType映射
'Boolean Number String Function Array Date RegExp Object Error Symbol Set Map'
  .split(' ')
  .map((item, index) => {
    classType['[object ' + item + ']'] = item.toLowerCase()
  })

type = obj => {
  // 一箭双雕
  if (obj == null) {
    return obj + ''
  }
  return typeof obj === 'object' || typeof obj === 'function'
    ? classType[Object.prototype.toString.call(obj)] || 'object'
    : typeof obj
}
```
