---
layout: post
title: 常用的数据处理方法
date: 2018-12-10
categories: JavaScript
tags:
  - JavaScript
  - 前端
  - ES6
---

数据处理：分类，数组去重

最后修改日期 2019-05-18

<!-- more -->

## 数组去重

### 使用 `indexOf` 和 `includes`

```js
  indexOf(arr = []) {
    const res = []
    arr.forEach((item) => {
      if (res.indexOf(item) === -1) {  //!res.includes(item)
        res.push(item)
      }
    })
    return res
  }
```

### filter

```js
filter(arr = []) {
  return arr.filter((item, index, arr) => {
    return arr.indexOf(item) !== item
  })
}

filter(arr=[]) {
  // arr.concat() 复制出来一份原有的数组，且对复制出来的新数组的操作不会影响到原有数组
  return arr.concat()sort().filter((item,index,arr) => {
    return !item || arr[index - 1] !== item
  })
}
```

### Object 键值对

```js
const array = [{value: 1}, {value: 1}, {value: 2}];

unique(array = []) {
    const obj = {};
    return array.filter(function(item, index, array){
        // console.log(typeof item + JSON.stringify(item))
        return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)
    })
}

console.log(unique(array)); // [{value: 1}, {value: 2}]
```

### Set 、Map 和 ...rest

> 使用 Set 可以区分出 `NAN`, 因为 `NAN` 不等于自身，所以 `indexOf` 不能查找到，而使用 `Set` 就可以解决这个问题
> 注意： 由于`{} !== {} // true`， 所以对象默认是不重复的，使用 `JSON.stringify` 可以解决这个问题

```js
setArr(arr = []) {
  // Set 是值的集合，类似于数组，但是每个值都是唯一的
  return [...new Set(arr)]
}

mapArr(arr = []) {
  // Map 是一个键值对集合，先检查有没有这哥属性，没有就添加尽这个集合中
  const seen = new Map(arr)
  return arr.filter(item => !seen.has(a) && seen.set(a,1))
}
```

## 数组分组

### 使用 `forEach` 遍历分组

```js
const list = [
  { label: 'a', value: 1 },
  { label: 'c', value: 3 },
  { label: 'b', value: 1 },
  { label: 'a', value: 3 },
  { label: 'c', value: 2 }
]
const collect = {}
list.forEach(item => {
  // console.log(item)
  if (!collect[item.label]) {
    collect[item.label] = []
  }
  collect[item.label].push(item)
})

// 处理后的数据
collect = {
  a: [1, 3],
  b: [1],
  c: [3, 2]
}

// 可以使用entries(),keys(),values()来获取所需要的值
```

### 使用 `30 seconds of code` 里 `reduce` 的方法

```js
const groupBy = (arr, fn) =>
  arr
    .map(typeof fn === 'function' ? fn : val => val[fn])
    .reduce((acc, val, i) => {
      acc[val] = (acc[val] || []).concat(arr[i])
      return acc
    }, {})
const collect = groupBy(list, item => item.label)
```
